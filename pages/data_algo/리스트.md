---
title: 자료구조 리스트
keywords: 리스트, 배열, 연결 리스트
last_updated: October 12, 2017
tags: [자료구조]
summary: "자료구조 리스트에 대해 학습합니다."
sidebar: data_algo_sidebar
permalink: 리스트.html
folder: data_algo
---

# 리스트

## 개요

리스트란 추상적 자료형으로 자료구조의 하나입니다. 순열(Sequence)이라고도 불리며, 순서를 가지고있고 중복을 허용하며 일렬로 나열한 원소들의 모임으로 정의합니다. 순서가 있다는 점에서 집합과는 구별되며, 갈림길 없이 일렬로 나열되어 처음과 끝이 각각 하나씩만 있다는 점에서 그래프와도 구별됩니다.

## 리스트의 종류

리스트에는 배열을 이용해 만든 배열 기반의 순차 리스트와 메모리의 동적 할당을 기반으로 구현된 연결 리스트로 크게 나뉩니다. 배열 기반의 리스트는 인덱스를 이용한다면 자료를 검색하는데 시간이 거의 안걸리고 대부분의 언어에서 기본적으로 배열을 제공하기 때문에 구현하기 굉장히 쉽다는 장점이 있습니다(사실 배열 자체로 이미 훌륭한 리스트입니다). 하지만 중간에 데이터를 삽입하거나 삭제한다면 빈자리를 마련해주거나 메꾸려고 데이터의 대규모 이동이 일어나므로 큰 손실이 일어납니다.  

![list](https://zerobugplz.github.io/images/studying/linkedlist.png)  

하지만 연결 리스트를 사용한다면 자료의 검색은 상대적으로 오래걸리는 대신에 데이터의 삽입이나 삭제시에 시간이 거의 걸리지 않습니다.  
연결 리스트는 단순 연결 리스트, 원형 연결 리스트, 양방향 연결 리스트로 나뉩니다.

### 단순 연결 리스트

배열 기반의 리스트는 자료가 하나 삭제되면 그 자료 뒤의 자료들이 한 칸씩 위치를 당겨야 해서 데이터의 복사가 빈번하게 일어난다는 단점이 있습니다.  
하지만 데이터가 생성되고 다른 데이터가 추가된다면 이전 데이터가 다음 데이터를 가리키는 식으로 리스트를 짠다면 어떨까요?  
데이터가 삭제되더라도 가리키는 포인터부분만 수정해주면 되므로 파일의 복사가 빈번하게 일어나지 않을 것입니다.  
아래는 윤성우님의 열혈 자료구조에서 발췌한 코드입니다.  

**헤더파일**

```
#ifndef __D_LINKED_LIST_H__
#define __D_LINKED_LIST_H__

#define TRUE	1
#define FALSE	0

typedef int LData;

typedef struct _node
{
	LData data;
	struct _node * next;
} Node;

typedef struct _linkedList
{
	Node * head; //더미 노드를 가리키는 멤버
	Node * cur; //참조 및 삭제를 돕는 멤버
	Node * before; //삭제를 돕는 멤버
	int numOfData; //저장된 데이터의 수를 기록하기 위한 멤버
	int (*comp)(LData d1, LData d2); //정렬의 기준을 등록하기 위한 멤버
} LinkedList;


typedef LinkedList List;

void ListInit(List * plist);
void LInsert(List * plist, LData data);

int LFirst(List * plist, LData * pdata);
int LNext(List * plist, LData * pdata);

LData LRemove(List * plist);
int LCount(List * plist);

void SetSortRule(List * plist, int (*comp)(LData d1, LData d2));

#endif
```

**함수 구현부 파일**

```
#include <stdio.h>
#include <stdlib.h>
#include "DLinkedList.h"

void ListInit(List * plist) // 초기화를 진행시켜줌
{
	plist->head = (Node*)malloc(sizeof(Node)); //더미 노드의 생성
	plist->head->next = NULL;
	plist->comp = NULL;
	plist->numOfData = 0;
}

void FInsert(List * plist, LData data) // comp가 NULL일 때 호출되는 함수
{
	Node * newNode = (Node*)malloc(sizeof(Node)); // 새 노드 생성
	newNode->data = data; // 새 노드에 데이터 저장

	newNode->next = plist->head->next; // 새 노드가 다른 노드를 가리키게 함
	plist->head->next = newNode; // 더미 노드가 새 노드를 가리키게 함

	(plist->numOfData)++; // 저장된 노드의 수를 하나 증가시킴
}

void SInsert(List * plist, LData data)
{
	Node * newNode = (Node*)malloc(sizeof(Node));
	Node * pred = plist->head;
	newNode->data = data;

	while(pred->next != NULL && plist->comp(data, pred->next->data) != 0)
	{
		pred = pred->next;
	}

	newNode->next = pred->next;
	pred->next = newNode;

	(plist->numOfData)++;
}


void LInsert(List * plist, LData data)
{
	if(plist->comp == NULL) //정렬기준이 마련되지 않았다면
		FInsert(plist, data); //머리에 노드를 추가!
	else //정렬기준이 마련되었다면
		SInsert(plist, data); //정렬기준에 근거하여 노드를 추가!
}

int LFirst(List * plist, LData * pdata)
{
	if(plist->head->next == NULL) // 더미 노드가 NULL을 가리킨다면,
		return FALSE; // FALSE를 반환한다.

	plist->before = plist->head; // before는 더미 노드를 가리키게 한다.
	plist->cur = plist->head->next; // cur은 첫 번째 노드를 가리키게 한다.

	*pdata = plist->cur->data; // 첫 번째 노드의 데이터를 전달한다.
	return TRUE; // 데이터 반환 성공!
}

int LNext(List * plist, LData * pdata)
{
	if(plist->cur->next == NULL) // 더미 노드가 NULL을 가리킨다면
		return FALSE; // 반환할 데이터가 없다!

	plist->before = plist->cur; // cur이 카리키던 것을 before이 가리킴
	plist->cur = plist->cur->next; // cur은 그 다음 노드를 가리킴

	*pdata = plist->cur->data; // cur이 가리키는 노드의 데이터 전달
	return TRUE; // 데이터 반환 성공
}

LData LRemove(List * plist)
{
	Node * rpos = plist->cur; // 소멸 대상의 주소 값을 rpos에 저장
	LData rdata = rpos->data; // 소멸 대상의 데이터를 rdata에 저장

	plist->before->next = plist->cur->next; // 소멸 대상을 리스트에서 제거
	plist->cur = plist->before; // cur이 가리키는 위치를 재조정!

	free(rpos); // 리스트에서 제거된 노드 소멸
	(plist->numOfData)--; // 저장된 데이터의 수 하나 감소
	return rdata; // 제거된 노드의 데이터 반환
}

int LCount(List * plist)
{
	return plist->numOfData;
}

void SetSortRule(List * plist, int (*comp)(LData d1, LData d2))
{
	plist->comp = comp;
}
```

위에서 head가 더미파일을 가리키게 한 이유는 더미가 없다면 노드를 추가, 삭제, 조회하는 방법에 있어서 첫 번째 노드와 두 번째 이후의 노드에 차이가 있게 됩니다.  
더미를 넣어둔다면 처음 추가되는 노드가 구조상 두 번째 노드가 되므로 그 과정을 일관된 형태로 구현할 수 있습니다.  
쉽게 이야기 하자면 head가 첫 데이터를 가리켜야 하는 특수성으로 코드를 head와 그렇지 않은 노드를 구분해서 짜야 하는데 더미파일을 삽입한다면 일관되게 코드를 짤 수 있다는 말입니다.  
  
**메인 파일**

```
#include <stdio.h>
#include "DLinkedList.h"

int WhoIsPrecede(int d1, int d2)
{
	if(d1 < d2)
		return 0;    // d1이 정렬 순서상 앞선다.
	else
		return 1;    // d2가 정렬 순서상 앞서거나 같다.
}

int main(void)
{
	// List의 생성 및 초기화  ////////////
	List list;
	int data;
	ListInit(&list);

	SetSortRule(&list, WhoIsPrecede); // 정렬의 기준을 등록한다.

	// 5개의 데이터 저장  ///////////////
	LInsert(&list, 11);  LInsert(&list, 11);
	LInsert(&list, 22);  LInsert(&list, 22);
	LInsert(&list, 33);

	// 저장된 데이터의 전체 출력 ////////////
	printf("현재 데이터의 수: %d \n", LCount(&list));

	if(LFirst(&list, &data))
	{
		printf("%d ", data);

		while(LNext(&list, &data))
			printf("%d ", data);
	}
	printf("\n\n");

	// 숫자 22을 검색하여 모두 삭제 ////////////
	if(LFirst(&list, &data))
	{
		if(data == 22)
			LRemove(&list);

		while(LNext(&list, &data))
		{
			if(data == 22)
				LRemove(&list);
		}
	}

	// 삭제 후 저장된 데이터 전체 출력 ////////////
	printf("현재 데이터의 수: %d \n", LCount(&list));

	if(LFirst(&list, &data))
	{
		printf("%d ", data);

		while(LNext(&list, &data))
			printf("%d ", data);
	}
	printf("\n\n");
	return 0;
}
```
