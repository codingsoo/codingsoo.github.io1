---
title: 자료구조와 알고리즘 필수 개념
keywords: 자료구조 선행 개념, 알고리즘 선행 개념
last_updated: October 7, 2017
tags: [자료구조, 알고리즘]
summary: "자료구조와 알고리즘을 공부하기에 앞서 알고 있어야 할 기본 지식에 대해 알아봅시다."
sidebar: data_algo_sidebar
permalink: 자료구조-알고리즘-필수개념.html
folder: data_algo
---

# 자료구조 필수 선행 개념

## 데이터 추상화와 캡슐화

캡슐화 : 관련있는 데이터와 함수를 묶고 실제 구현 내용 일부를 외부에 감추어 은닉한다. 간접적 접근경로는 제공해야함.

```
class Point{
private:
    int x;
    int y;
public:
    int GetX() {return x;}
    int GetY() {return y;}
    void SetX(int _x);
    void SetY(int _y);
    void Showdata();
};

void Point::Showdata() {//내용}

int main() {
    p.SetX(x);
    p.SetY(y);
    p.Showdata();
}
```

위의 코드는 점에 대한 정보를 클래스에서 잘 묶어놓고 있습니다.  
그리고 실질적인 데이터에 대한 간접적 접근경로도 제공하고 있으므로 캡슐화되었다고 볼 수 있습니다.  
  
추상화 : 무엇과 어떻게를 구분하는 것. 데이터의 명세와 구현을 분리함.  
  
위의 예제에서 x와 y는 데이터 즉 무엇이고, public에 있는 함수들은 기능 어떻게에 해당합니다.  
  
**추상화 와 캡슐화의 장점**  
  
1. 소프트웨어 개발의 간소화: 복잡한 작업을 부분작업들로 분해 (분업 가능)
2. 검사와 디버깅의 단순화: 부분 작업
3. 재 사용성: 자료 구조가 시스템에서 별개의 개체로 구현

## 자료구조의 구분

- 선형(linear) 과 비선형(non-linear)으로 구분합니다.
- 자료구조내의 요소들이 순차적인 형식이면 선형, 아니면 비선형입니다.
- 선형자료구조에는 배열과 연결 리스트가 있습니다.
- 배열: 순차적 메모리 주소에 의하여 요소들간의 관계를 표현하는 구조입니다.
- 연결리스트: 포인터를 사용하여 요소들간의 관계를 표현입니다.
- 비선형 자료구조: 트리(tree) 와 그래프(graph)가 있습니다.

## 배열의 특징

- 연속적 기억장소(메모리 위치)의 집합
- 대부분의 언어에서 제공하는 가장 단순한 구조적 자료형
- 동일한 자료형 (Same data type for elements)
- 선언시 크기지정. 크기보다 많은양의 자료 저장 => overflow
- 정적 자료형 (compile 시 크기를 알아야 하고, 실행 되는 동안 크기가 변하지 않는다)
- Set of mappings between index and values ; <index, value>

장점: 이해 쉽고, 사용하기 편함, 자료저장이 용이(예: A[4]=10)  
  
단점: 동일한 자료만 저장, 미리 크기 선언(필요이상 크기선언시, 공간낭비, 많은 자료이동으로 삽입 삭제 느림).  

## Struct and Union

- 타입이 다른 데이타를 그룹화 (레코드)
- 데이터 항목의 집단. 각 항목은 타입과 이름으로 식별함.

**struct 사용 예시**

```
typedef struct _person{
char name[10];
int age;
float salary;
} person;

person p1, p2, p3;
```
  
**구조체 속의 또 다른 구조체 정의**

```
typedef struct _person{
char name[10];
int age;
float salary;
} person;

typedef struct _officeWorker{
    person p1;
    int salary;
} officeWorker;
```

**Union: 메모리 공간 공용. 한필드만 한시점에 사용**
  
```
#include <stdio.h>

typedef union _IP_ADDR{
    int nAddress;
    short awData[2];
    unsigned char addr[4];
} IP_ADDR;

int main()
{
    IP_ADDR addr;

    addr.addr[0] = 192;
    addr.addr[1] = 164;
    addr.addr[2] = 10;
    addr.addr[3] = 3; // 192.164.10.3 IP 주소 저장

    printf("%d\n",addr.nAddress); // 51029184로 다르게 표현 가능

    return 0;

}
```

## 자체참조 구조 (self_referential structure)

구성요소 중 자신을 가리키는 포인터가 존재하는 구조

```
typedef struct _list{
    struct _list *l1;
    char data;
}list;
```

# 알고리즘 필수 선행 개념

## 시간 복잡도와 공간 복잡도

시간 복잡도는 실행 속도에 대한 이슈를 다루고 공간 복잡도는 메모리의 사용량에 대한 이슈를 다룹니다.  
그러나 대게는 메모리가 요새 충분하기 때문에 공간 복잡도는 생각을 많이 안하고 시간 복잡도만 고려하는 경우가 많습니다.  
시간 복잡도는 보통 연산의 횟수를 세서 계산합니다.  
데이터의 수에 따른 연산횟수의 증가량을 파악해서 알고리즘의 성능을 판단하는 것입니다.  
쉽게 생각하면 다중 for문이 많을수록 데이터 수에 따라 연산이 급격하게 증가하므로 수행 시간도 길게 나타나는 것을 떠올리면 될 것 같습니다.  

### 공간 복잡도

프로그램의실행에필요한공간 : S(P)=c+SP(I)  
(S(P): 전체공간, c: 고정공간, SP(I): 가변공간)  

고정기억공간요구 : 프로그램입출력횟수나크기와관계없는공간요구 (fixed space requirements)  
ex) 프로그램 코드(명령어) 저장 공간, 단순변수, 고정 크기의 구조화 변수, 상수 등 저장할 공간  

가변공간요구: variablespacerequirements  
  
a. 가변크기의 구조체 (예: A[])  
b. 문제의 instance i 에 의존하는 공간  
c. recursion 의 경우 추가공간 소요 (지역변수, 매개변수, return address 등)  
  
예제1)  
```
float sum(float list[], int n)
{
float tsum = 0; int i;
for (i = 0; i < n; i++) tsum += list[i];
return tsum;
소요공간:
1) C/C++배열을 전달할 때, 배열의 주소를 전달함 (call by ref), 따라서 소요공간은 배열의 주소 값 => 4bytes
2) 매개변수 n, 지역변수 tsum, I 의 공간 (4*3=12 bytes) 
3) 가변 공간 없음... 모두 16bytes
}
```
예제2)  
```
float rsum(float list[], int n)
{
if (n) return rsum(list, n-1) + list[n-1];
return 0;
}
소요공간:
1) 배열주소 list 값을 위한 data 변수 => 4bytes
2) 매개변수 n=4bytes
3) 반환주소 공간: 4bytes
4) 따라서 매회 호출시 마다 3*4=12bytes 소요됨. n 번 호출시, 총 소요공간은 12*n.
```

### 시간 복잡도

프로그램의 실행에 필요한 시간 (프로그램 P 에 의해 소요되는 시간 : T(P))  

1. 컴파일 시간 + 실행 시간 (Tp) 으로 구성됨
2. 컴파일 시간은 프로그램의 특성에 영향없음 -> run time 만 고려
3. 가장 좋은 방법: 시스템 clock 사용
4. 다른 방법: 프로그램이 수행하는 연산의 횟수계산  
  
시간 복잡도 구하는 예시 1

```
1. float sum (float list[], int n); 0
2. {                                0
3. float tempsum=0;                 1
4. int i;                           0
5. for(i=0;i<n;i++) n+1             n+1
6.      tempsum += list[i];         n
7. return tempsum;                  1
8. }                                0
Total Steps: 2n+3
```

시간 복잡도 구하는 예시 2

```
float sum(float list[], int n) 0
{                              0 
    float tempsum = 0;         1 
    int i;                     0
    for(i=0;i<n;i++)           n+1
        count += 2;            n
    count += 3;                1
    return 0;                  1
}
total steps in counts : 2n + 4 steps
```

## 점근 표기법

점근 표기법(asymptotic notation)은 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법이다. 알고리즘의 복잡도를 단순화할 때나 무한급수의 뒷부분을 간소화할 때 쓰입니다. 대표적으로 다음의 다섯 가지 표기법이 있습니다.

- 대문자 O 표기법
- 소문자 o 표기법
- 대문자 오메가(Ω) 표기법
- 소문자 오메가(ω) 표기법
- 대문자 세타(Θ) 표기법

가장 많이 쓰이는 방식은 대문자 O 표기법 입니다(빅 오라고 부릅니다).  
복잡도가 이정도 될 것이다! 라고 짐작하게 해주는 표기법이라고 생각하시면 됩니다. 정확할 필요는 없습니다.  
예를들어 O(2n^2+3n+4) = O(2n^2+3n) = O(2n^2) = O(n^2) 으로 보는 것입니다. 세세한 계수나 낮은 차수들은 무시해버립니다.  
