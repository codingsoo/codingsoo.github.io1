---
title: C언어 실수 자료형
keywords: C언어 실수 자료형, float, double
last_updated: September 15, 2017
tags: [C언어]
summary: "C언어 실수 자료형에 대한 이야기"
sidebar: c_language_sidebar
permalink: C언어-실수자료형.html
folder: c_language
---

## 실수 자료형

### 실수 자료형의 종류
---
- float	4 Bytes => 1.175494e-38 ~ 3.402823e+38(소수점자리 6번째까지 잘 표현됨)
- double 8 Bytes => 2.225074e-308 ~ 1.797693e+308(소수점자리 15번째까지 잘 표현됨)
- long double 8(윈도우) Bytes ~ 16(MAC) Bytes로 OS별로 다름

### 컴퓨터의 실수 표현 방식과 부동 소수점 오차
---
정수 연산과 달리 실수 연산에서는 오차가 존재합니다. 아래의 코드는 0.0에 0.1을 100번 더해주어서 10이 나와야 하지만 결과는 그렇지 않습니다.

```
#include <stdio.h>

int main()
{
    float num1 = 0.0f;
    float num2 = 0.1f;

    // 0.1을 10번 더함
    for (int i = 0; i < 100; i++)
    {
        num1 = num1 + num2;
    }

    printf("%.15f\n", num1);

    return 0;
}
출력 결과 :
10.000001907348633
```

그 이유를 알기 위해서는 컴퓨터가 정수와 실수를 표현하는 데 차이가 있음을 알아야 합니다. 정수 연산에서는 기본적으로 2의보수라는 연산방법을 취합니다(이전 포스팅에서 설명했습니다). 실수는 정수와 달리 1대1 매칭 형식으로 저장 할 수가 없습니다. 그도 그럴 것이 1과 2사이에 있는 실수의 개수만 해도 무한대입니다.  
**1대1로 매칭하는 것은 불가능하고 근사값으로 접근해야겠죠?**  
부동 소수점 표현 방식으로 표현하는데 수를  ${1.m}^{e-127}$와 같이 유효숫자를 사용한 곱셈 형태로 표현합니다. 실제 사용되고 있는 부동 소수점 방식은 대부분 IEEE 754 표준을 따릅니다. 이 규격에서는 실수를 32비트로 처리하는 단정밀도(single precision)에서는 부호 1비트, m부분 8비트, e부분 23비트를 사용하며, 64비트로 처리하는 배정밀도(double precision)에서는 부호 1비트, m부분 11비트, e부분 52비트를 사용합니다.  
예를 들어, 앞의 보기와 같이 실수값 -0.4을 16비트 부동소수점으로 처리하되, 가수부는 10비트, 지수부는 5비트라면, 먼저 값을 이진수로 변환하면 0.0110011001100110(2)이고, 정규화 결과는1.10011001100110(2)×2^(-2)이므로, 가수는1.10011001100110(2), 지수는 -10(2)이 됩니다.  
음수값이므로 부호부는 '1'이 되고, 지수는 5비트이므로 바이어스 상수는 25-1 - 1 = 15입니다. 따라서, 지수부는 '01101'이 된다. 가수부는 소수 부분만 10비트로 나열하여 '1001100110'이 됩니다. 부호-지수-가수의 순서로 조합하여 최종적으로는 16비트 1011011001100110를 얻게 됩니다.  

### 실수 자료형 사용하기
---
```
#include <stdio.h>

int main()
{
    float num1 = 0.1f;
    double num2 = 123.4567;
    long double num3 = 1.23456l;

    printf("%f %f %Lf\n", num1, num2, num3);

    return 0;
}
출력 결과 :
0.1 123.4567 1.23456l
```

float는 숫자 뒤에 f를, long double은 숫자 뒤에 l을 붙여줘야 합니다. double은 아무것도 붙이지 않아도 됩니다. 그리고 출력할 때에는 서식문자로 float와 double은 %f를 쓰고 long double은 %Lf를 사용합니다. 실수는 지수 표기법으로 저장할 수도 있습니다.

```
#include <stdio.h>

int main()
{
    float num1 = 0.1e2f;
    double num2 = 123e-2;
    long double num3 = 40e-1l;

    printf("%f %f %Lf\n", num1, num2, num3);

    return 0;
}
출력 결과 :
10.000000 1.230000 4.000000
```

### 최소값과 최대값 표현하기
---
정수 자료형에서 limit.h와 같은 기능을 하는 헤더파일이 실수 자료형을 대상으로도 존재합니다. 바로 float.h인데 이걸 통해서 우리는 정수 자료형의 최소값과 최대값을 손쉽게 구할 수 있습니다. %e(지수형으로 나타내어주는 서식문자)를 이용하여 표현해 보겠습니다.

```
#include <stdio.h>
#include <float.h>

int main()
{
    float num1 = FLT_MIN;
    double num2 = DBL_MAX;
    long double num3 = LDBL_MIN;

    printf("%e\n %e\n %Le\n", num1, num2, num3);

    return 0;
}
출력 결과 : 
1.175494e-38
1.797693e+308
3.362103e-4932

```

### 언더플로우와 오버플로우
---
실수 자료형에서도 정수 자료형과 마찬가지로 언더플로우와 오버플로우가 발생할 수 있습니다. 정수 자료형에서 이것이 무엇인지는 설명했으므로 따로 언급하지는 않겠습니다. 언더플로우의 경우 실수는 0 또는 쓰레기 값을 만듭니다. 오버플로우의 경우 무한대를 의미하는 inf가 출력됩니다.  