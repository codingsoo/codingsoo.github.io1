---
title: C언어 연산자
keywords: C언어 산술 연산자, C언어 복합 대입 연산자, C언어 형 변환 연산자, C언어 단항 연산자 등
last_updated: September 16, 2017
tags: [C언어]
summary: "C언어 연산자에 대한 이야기"
sidebar: c_language_sidebar
permalink: C언어-연산자.html
folder: c_language
---

## 연산자

### 산술 연산자
---
산술연산자는 사칙연산자을 의미합니다. C언어에서는 특별히 나머지를 구하는 연산자도 있습니다. 산술연산자는 피연산자 2개를 필요로 하므로 이항 연산자의 일종입니다.  

- 덧셈 + => x와 y를 더한다. x+y
- 뺄셈 - => x에서 y를 뺀다. x-y
- 곱셈 * => x와 y를 곱한다.  x*y
- 나눗셈 / => x를 y로 나눈다. x/y
- 나머지 % => x를y로나눌때의나머지값 x%y

```
#include <stdio.h>

int main()
{
    int num=10;

    num = num-1;

    printf("현재 num의 값 : %d\n",num);

    num = num+1;

    printf("현재 num의 값 : %d\n",num);

    return 0;
}
출력 결과:
현재 num의 값 : 9
현재 num의 값 : 10
```

### 복합 대입 연산자
---
num을 두 번 입력 안하고도 -= 연산자와 += 연산자를 쓰면 변수의 값을 업데이트 할 수 있습니다. 나머지 연산자들도 *=, /=, %= 꼴로 같은 방식으로 축약형을 지원합니다.  

```
#include <stdio.h>

int main()
{
    int num=10;

    num -= 1;

    printf("현재 num의 값 : %d\n",num);

    num += 1;

    printf("현재 num의 값 : %d\n",num);

    return 0;
}
출력 결과:
현재 num의 값 : 9
현재 num의 값 : 10
```

### 형 변환 연산자
---
괄호 안에 변환하고 싶은 형을 입력하면 그 형으로 변환이 됩니다. 아래의 경우 정수인 2를 실수형으로 변환하여 연산하고 출력했습니다.

```
#include <stdio.h>

int main()
{
    printf("%d\n",5/2);
    printf("%lf\n",5/(double)2);
    
    return 0;
}

출력 결과:
2
2.500000
```

### 단항 연산자
---
단항 연산자는 피연산자의 개수가 1개인 연산자를 의미합니다. C언어에서는 1을 더하거나 뺄 일이 많습니다. 이를 위해 1을 증가시키거나 감소시키는 특별한 연산자를 제공해 줍니다.  
  
- 변수++; // 변수의 값을 유지하고 다음 라인에서부터 변수의 값이 1 증가  
- ++변수; // 즉시 변수의 값이 이번 라인에서 1 증가  
- 변수--; // 변수의 값을 유지하고 다음 라인에서부터 변수의 값이 1 감소  
- --변수; // 즉시 변수의 값이 이번 라인에서 1 감소  

```
#include <stdio.h>

int main()
{
    int num=10;

    printf("현재 num의 값 : %d\n",num++);
    printf("현재 num의 값 : %d\n",num);

    printf("현재 num의 값 : %d\n",num--);
    printf("현재 num의 값 : %d\n",num);

    return 0;
}
출력 결과:
현재 num의 값 : 10
현재 num의 값 : 11
현재 num의 값 : 11
현재 num의 값 : 10
```

위에서 보시듯이 ++이나 --를 뒤에 붙이면 그 다음 라인부터 1이 증감하게 됩니다. 이번에는 연산자를 앞에 붙이면 바로 1이 증감하게 되는 것을 보겠습니다.

```
#include <stdio.h>

int main()
{
    int num=10;

    printf("현재 num의 값 : %d\n",++num);
    printf("현재 num의 값 : %d\n",num);

    printf("현재 num의 값 : %d\n",--num);
    printf("현재 num의 값 : %d\n",num);

    return 0;
}
출력 결과:
현재 num의 값 : 11
현재 num의 값 : 11
현재 num의 값 : 10
현재 num의 값 : 10
```

### 관계 연산자
---
관계 연산자는 두 개의 피연산자를 비교하는 연산자료 결과물은 항상 0 아니면 1입니다. 관계가 거짓이면 0, 참이면 1이 되는 것입니다.유의할 점은 절대 상등, 부등 연산자를(==나 !=) 실수에는 사용하면 안된다는 것입니다. 실수는 이전에 다루었듯이 정확한 값이 아닌 근사값을 표현합니다. 따라서 값이 명확하지 않으므로 관계연산자를 사용하면 결과값이 예상과 다르게 나올 수 있습니다.  

- x와 y가 같은가? == **x == y**
- x와 y가 다른가? != **x != y**
- x가 y보다 큰가? < **x > y**
- x가 y보다 작은가? > **x < y**
- x가 y보다 크거나 같은가? >= **x >= y**
- x가 y보다 작거나 같은가? <= **x <= y**

```
#include <stdio.h>

int main()
{
    int x=1, y=2;

    printf("%d\n",x==y); // 1과 2는 같지 않으므로 0
    printf("%d\n",x!=y); // 1과 2는 다르므로 1
    printf("%d\n",x>y); // 1이 2보다 크지 않으므로 0
    printf("%d\n",x<y); // 1은 2보다 작으므로 1
    printf("%d\n",x<=y); // 1은 2이하이므로 1
    printf("%d\n",x>=y); // 1은 2이상이 아니므로 0

    return 0;
}
출력 결과:
0
1
0
1
1
0
```

주의할 점은 아래와 같은 코드는 성립되지 않는다는 것입니다.  

```
#include <stdio.h>

int main()
{
    int x=3;

    printf("%d\n",1<x<2); // 3은 1과 2 사이에 있는가?
    
    return 0;
}
출력 결과:
1 // 잘못된 결과
```

결과가 잘못되는 이유는 C언어는  1 < x < 2를 아래와 같이 인식하기 때문입니다.  

> 1 < x < 2 => (1 < x) < 2 => (1 < 3) < 2 => 0 < 2 => 1  

앞에서부터 계산해서 해당 식이 참인지 거짓인지를 먼저 판별하고 0이나 1을 반환해 버리고 이것을 뒤의 식과 비교합니다. 따라서 위의 코드는 아래와 같이 개선되어야 합니다.  

```
#include <stdio.h>

int main()
{
    int x=3;

    printf("%d\n",(1<x)&&(x<2));

    return 0;
}
출력 결과:
0
```

&&는 논리 연산자로 and의 기능을 합니다. 바로 뒤에서 살펴보도록 하겠습니다.  

### 논리 연산자
---
위에서 1<x<2의 오류 예제를 보았습니다. &&로 손쉽게 논리를 묶어서 오류를 해결했었습니다. 논리 연산자란 여러 개의 조건을 조합하여 참과 거짓을 따지는 연산자입니다.  

```
&& => AND 연산, x와 y가 모두 참이면 참, 그렇지 않으면 거짓
|| => OR 연산, x나 y중에서 하나만 참이면 참, 모두 거짓이면 거짓
! => NOT 연산, x가 참이면 거짓, x가 거짓이면 참
```
여러개의 조건을 손 쉽게 묶어주는 기능을 합니다.  
```
x는 1보다 크고 2보다 작다 => (x>1)&&(x<2)
y는 5보다 작거나 10보다 크다 => (y<5) || (y>10)
```
논리 연산자를 적용하는 데는 short circuit 방식을 이용합니다. 왼쪽에서 오른쪽 방향으로 이동하며 연산할 필요가 없으면 연산을 하지 않는 것입니다.

```
#include <stdio.h>

int main()
{
    1 == 1 || printf("printed1\n"); // 1==1에서 참이므로 ||(or) 이후 문장과 관계 없이 참이므로 뒷 문장 실행 안됨
    1 == 1 && printf("printed2\n"); // 1==1이 참이더라도 &&(and)이므로 모든 조건 다 참인지 확인해야해서 뒤에꺼 코드도 출력됨
    1 == 2 || printf("printed3\n"); // 1==2가 거짓이므로 ||(or) 이후 문장이 참인지 확인 필요하므로 실행됨
    1 == 2 && printf("printed4\n"); // 1==2가 거짓이므로 &&(and) 이후 문장과 관계 없이 거짓이므로 뒷 문장 실행 안됨

    return 0;
}
```


### 비트 연산자
---
(대부분의 운영체제에서) int는 32비트(4바이트)일 것입니다.  
예를들어 int i = 1; 의 경우 i가 실제로 저장되는 값은 00000000 00000000 00000000 00000001 일 것입니다.  
비트 연산자는 비트단위로 연산을 할 수 있도록 하게 해줍니다.  
위에서 언급한 i와 int x = 12; x=> 00000000 00000000 00000000 00001100 로 예제를 주도록 해보겠습니다.

```
& => 비트 AND => 두개의 피연산자의 해당 비트가 모두 1이면 1, 아니면 0
| => 비트 OR => 두개의 피연산자의 해당 비트중 하나만 1이면 1, 아니면 0
^ => 비트 XOR => 두개의 피연산자의 해당 비트의 값이 같으면 0, 아니면 1
<< => 왼쪽으로 이동 => 지정된 개수만큼 모든 비트를 왼쪽으로 이동한다. 오른쪽에 비게되는 부분은 0으로 채워줌.
>> => 오른쪽으로 이동 => 지정된 개수만큼 모든 비트를 오른쪽으로 이동한다. 왼쪽에 비게되는 부분은 첫번째 자리가 1이면 1, 0이면 0으로 채워줌
~ => 비트 NOT => 0은 1로, 1은 0으로 만든다.
```

&와 <<의 예시만 대표적으로 살펴보도록 하겠습니다.  

```
#include <stdio.h>

int main()
{
    int x=12;
    int i=1;

    printf("%d\n",i&x);

    return 0;
}
출력 결과:
0

i & x
비트의 위치가 둘다 1이면 1, 둘 중 하나라도 0이면 0이 됨
00000000 00000000 00000000 00000001
00000000 00000000 00000000 00001100
-----------------------------------
00000000 00000000 00000000 00000000
```

```
#include <stdio.h>

int main()
{
    int i=1;

    printf("%d\n",i<<1);
    printf("%d\n",i<<2);

    return 0;
}
출력 결과:
2
4

i << 1
비트의 위치를 왼쪽으로 1칸씩 이동함
00000000 00000000 00000000 00000001 => 
00000000 00000000 00000000 00000010

i << 2
비트의 위치를 왼쪽으로 2칸씩 이동함
00000000 00000000 00000000 00000001 => 
00000000 00000000 00000000 00000100
```

### sizeof 연산자
---
어떤 변수, 상수, 자료형 등이 차지하는 바이트수를 리턴해줍니다. CPU가 계산하는 것이 아니라 컴파일러가 컴파일을 할 때에 수행하는 것으로 CPU가 실행하지 않으므로 프로그램의 성능에 영향을 끼치지 않습니다.

```
#include <stdio.h>

int main()
{
    printf("%d\n", sizeof('1')); // 문자 1은 1바이트이므로 1이 출력됨
    printf("%d\n", sizeof(1)); // 숫자 1은 4바이트이므로 4가 출력됨
    return 0;
}
```

### 삼항 연산자
---
조건을 주고 조건이 참이면 : 기준으로 앞의 문장을, 거짓이면 뒤의 문장을 실행합니다.

> 조건 ? 참일 경우 실행할 문장 : 거짓일 경우 실행할 문장

```
#include <stdio.h>

int main()
{
    1 > 0 ? printf("앞의 문장\n") : printf("뒤의 문장\n");
    1 < 0 ? printf("앞의 문장\n") : printf("뒤의 문장\n");

    return 0;
}
출력 결과:
앞의 문장
뒤의 문장
```