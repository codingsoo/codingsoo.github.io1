---
title: C언어 변수와 상수
keywords: C언어 변수, C언어 상수
last_updated: September 15, 2017
tags: [C언어]
summary: "C언어 자료형 이해의 밑바탕이 되는 변수와 상수에 대해 알아봅시다."
sidebar: c_language_sidebar
permalink: C언어-변수와-상수.html
folder: c_language
---

## 변수

### 변수란?
---
변수란 프로그램이 사용하는 데이터를 일시적으로 저장할 목적으로 사용하는 메모리 공간입니다. 쉽게 풀이하자면 데이터를 담는 상자라고 생각하면 됩니다. 어떤 자료형을 담는 상자를 사용할지는 C언어에서 미리 정의해준 자료형을 이용하면 됩니다. 우리는 이것을 이용하여 정수 자료형을 담는 변수를 선언할 수 있습니다. 아래와 같이 상황에 따라 유연하게 저장되는 값을 변경할 수 있는게 변수가 갖는 가장 큰 장점입니다. int는 다음장에서 배울 것이지만 미리 좀 살펴보겠습니다. 정수 자료형을 저장하는 키워드입니다.

```
int x; // 정수 자료형을 갖는 변수 x
int y; // 정수 자료형을 갖는 변수 y
x = 1; // x에 1 저장
y = 1; // y에 1 저장
x = 10; // x에 10 저장
y = 20; // y에 20 저장
```

### 변수의 이름
---
변수나 함수(다음 포스팅에서 다룹니다)의 이름을 식별자라고 합니다. 식별자를 만드는데는 아래와 같은 규칙이 있습니다.  

- 식별자는 영어의 대소문자, 숫자, 밑줄문자(_)로 이루어진다.
- 식별자는 숫자로 시작할 수 없다.
- 대문자와 소문자를 구별하며 C언어의 키워드와 똑같은 이름은 허용되지 않는다.

변수의 이름을 잘 만드는 것도 정말 중요한 일입니다. 변수의 이름을 만드는 일은 같이 작업하는 프로그래머와 협의할 필요가 있습니다. 포스팅을 계속 보시면서 제가 만든 변수명을 보며 익히시면 될 것 같습니다.

### 최적화와 변수 
---
변수는 프로그램에서 적게 선언될 수록 좋습니다. 이유는 프로그램 코드가 컴파일러에 의해 최적화 될 때에 변수가 많을수록 복잡도가 크게 증가하기 때문에 프로그램이 느려지기 때문입니다. 반드시 변수로 선언되어야 하는 것인지, 아니면 아래에서 배울 상수로 선언해도 되는 것인지 고민해본 뒤에 프로그램을 짜시기 바랍니다. 상수는 프로그램의 복잡도를 상대적으로 덜 증가시킵니다.

## 상수 자료형

### 리터럴과 상수
---
상수는 저장된 값의 변경이 불가능한 공간으로 const 키워드로 선언이 가능합니다. 변수는 한 번 선언하면 값을 계속해서 바꿀 수 있는데 반해 상수는 처음 선언할 때에만 값을 할당할 수 있으며 그다음부터는 값을 바꿀 수 없습니다. 리터럴은 문자 그대로라는 뜻으로 C언어에서는 그 값 자체를 의미합니다.  

```
const int con = 10;
```

위의 코드에서 10이 리터럴이고 con이 상수입니다. 상수의 핵심 기능은 값을 변경하지 못하게 하는데 있습니다. 아래의 코드는 상수인 con의 값을 변경하려고 했으므로 오류가 납니다.  

```
#include <stdio.h>

int main()
{
    const int con = 10;
    con = 20; // 오류!

    return 0;
}
```

### 리터럴 접미사
---
리터럴의 크기를 명확하게 표현하기 위해 접미사를 사용할 수 있습니다.  

```
#include <stdio.h>

int main()
{
    printf("%ld\n",123L); // long 크기의 정수 리터럴
    printf("%lu\n",123UL); // unsigned long 크기의 정수 리터럴
    printf("%lu\n",123ULL); // unsigned long long 크기의 정수 리터럴
    printf("%u\n",123U); // unsigned int 크기의 정수 리터럴
    printf("%f\n", 0.1f); // float 크기의 실수 리터럴
    printf("%f\n",0.1); // double 크기의 실수 리터럴
    printf("%lf\n",0.1L); // long double 크기의 실수 리터럴
    
    return 0;
}
```

## 변수 2번째 이야기 - 변수의 종류

### 개요
---
변수란 프로그램이 사용하는 데이터를 일시적으로 저장할 목적으로 사용하는 메모리 공간이라고 한 것을 기억하실 겁니다. 이전에는 변수의 이름, 타입, 크기, 값만을 고려하여 이야기한 것입니다. 하지만 변수에는 사실 범위, 생존시간, 연결의 특징도 있습니다. 오늘은 범위, 생존시간, 연결의 특징에 대해 알아보려고 합니다.  


### 지역변수
---
변수의 범위에는 지역변수와 전역변수가 있습니다. 지역변수는 함수 내부에서 선언된 변수를 의미합니다. 함수 내부에서만 사용이 가능하며 함수가 종료되면 변수도 소멸됩니다. 
 
```
#include <stdio.h>

int factorial(int n);

int main() {
    printf("5! = %d",i); // i가 선언이 안되었다고 오류를 냄

    return 0;
}

int factorial(int n) // 반환형 int, 함수 이름 factorial, 매개변수 int형 변수 n
{
    int i; // 함수 내의 지역변수로 함수 안에서만 사용 가능
    int result = 1;

    for(i = 1; i <= n; i++)
        result *= i;

    return result; // result 값을 반환(int 형)
}
```
 
factorial에서 선언한 i를 main함수에서는 사용할 수 없습니다. factorial에서 선언한 변수는 factorial에서만 사용할 수 있기 때문입니다.

### 전역변수
---
전역변수는 함수 외부에서 선언된 변수를 의미합니다. 소스파일 전체 어디서든 사용이 가능합니다.  

```
#include <stdio.h>

int factorial(int n);

int i;

int main() {
    
    printf("5! = %d",factorial(5));

    return 0;
}

int factorial(int n) // 반환형 int, 함수 이름 factorial, 매개변수 int형 변수 n
{
    int result = 1;

    for(i = 1; i <= n; i++)
        result *= i;

    return result; // result 값을 반환(int 형)
}
```

함수 외부에서 선언한 변수 i를 factorial 함수에서 접근하는 것을 볼 수 있습니다. 하지만 이런식으로 전역변수를 남용하는 것은 좋지 않습니다. 전역변수는 프로그램의 복잡성을 증가시키고 메모리 낭비가 발생하므로 가급적 사용하지 않는 것이 좋습니다.  

### 지역변수 + 전역변수
---
동일한 이름의 지역변수와 전역변수가 있다면 어떤 일이 일어날까요?  

```
#include <stdio.h>

int num = 5;

int main() {

    int num=10;

    printf("%d\n",num);

    return 0;
}
출력 결과:
10
```

지역변수와 전역변수가 동시에 선언되었다면 해당 함수에서는 지역변수를 사용합니다.  

### 저장유형 지정자
---

> 자동변수  

자동변수는 지역변수의 개념입니다. 해당 함수에서 변수가 생성되고 함수가 종료되면 변수도 소멸되는 것입니다. 다음의 예제에서 결과값은 무엇이 될까요?  

```
#include <stdio.h>

int num();

int main() {

    for(int i=0; i<10; i++)
        printf("%d\n",num());

    return 0;
}

int num()
{
    auto int num = 0;

    num = num + 1;

    return num;
}
```

1만 10개가 출력됩니다. 함수를 호출할 때마다 num이 새로 생성되고 소멸되므로 늘 num이 0으로 생겨서 1이 더해진 상태에서 반환되므로 1이 10개가 나오게 되는 것입니다.  

> static 변수

변수 자료형 앞에 static을 붙이면 함수가 끝나도 변수가 사라지지 않습니다. 그리고 선언은 한번만 적용됩니다. 즉 함수 안에 static int num=0;이 있고 호출이 여러번 되더라도 호출할 때마다 계속 0으로 초기화되는 것이 아닙니다. 초기화는 프로그램 실행시 한번만 적용됩니다.  
전역변수처럼 다른곳에서 쓸 수는 없다는 점에서 전역변수와는 차이가 있습니다.  

```
#include <stdio.h>

int num();

int main() {

    for(int i=0; i<10; i++)
        printf("%d\n",num());

    return 0;
}

int num()
{
    static int num = 0;

    num = num + 1;

    return num;
}
```

이번에는 출력 결과가 1부터 10까지 숫자가 차례대로 출력됩니다. num의 값이 계속해서 함수가 종료되도 남아있기 때문입니다.  
함수의 경우에도 앞에 static을 붙일 수 있습니다. 함수는 본래 컴파일이 같이 된다면 서로 다른 파일의 함수에 접근할 수 있습니다. 하지만 static이 붙은 경우에는 해당 파일 외에 다른 곳에서 사용을 안한다는 의미로 쓰입니다.  
Person.c, Police.c, Student.c 파일이 있다고 가정하겠습니다.  

```
// Person.c

static void SayHello()
{
    printf("Hello~!");
}
```
위의 SayHello함수는 Police.c와 Student.c에서 사용이 불가합니다.  

> register 변수

CPU에는 레지스터라는 곳이 있는데 변수 자료형 앞에 register int i = 0; 이런 식으로 register를 붙여주면 레지스터에 변수를 저장해주어서 빠르게 처리해줍니다. 하지만 **이부분은 컴파일러가 판단**해서 알아서 register가 붙어있어도 부적합하다고 생각이 들면 떼어주고 또 register 선언을 안해주어도 알아서 적합하다고 판단이 들면 레지스터에 저장을 해줍니다.  
따라서 사용자가 register 변수를 직접 선언할 일은 별로 없을 것입니다.  

> extern 변수

변수는 기본적으로 선언시 해당 파일에서만 사용할 수 있습니다. 외부 연결이란 서로 다른 파일에 있는 전역변수들을 extern 을 이용하여 서로 연결해주는 것입니다. 예를 들어서 Person.c, Police.c, Student.c 파일이 있다고 가정하겠습니다.  
Person.c에는 int age=10; 이라는 전역변수가 선언되어 있습니다. 이 전역변수를 Police.c와 Student.c에서 사용하려면 어떻게 해야할까요?  

```
// Police.c
extern int age;
```
```
// Student.c
extern int age;
```

위와 같이 서로 자신의 파일들에 extern 선언을 해주면 해당 변수가 다른 파일에 있음을 알려주어서 다른 파일에서 선언된 전역변수를 사용할 수 있게됩니다.  
