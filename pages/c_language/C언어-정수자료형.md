---
title: C언어 정수 자료형
keywords: C언어 정수 자료형, int
last_updated: September 15, 2017
tags: [C언어]
summary: "C언어 정수 자료형에 대한 이야기"
sidebar: c_language_sidebar
permalink: C언어-정수자료형.html
folder: c_language
---

## 정수 자료형

### 정수 자료형 사용하기
---
정수 자료형은 크게 char, int가 있으며 앞에 부호 키워드(signed, unsigned)와 크기(short, long)를 붙여서 특성을 정의할 수 있습니다. 자주 쓰이는 것은 char와 int 입니다.  

```
#include <stdio.h>

int main() {
    int num1 = 10; // int형 변수 num1 선언 및 값 초기화
    char num2 = 10; // char형 변수 num2 선언 및 값 초기화
    printf("%d\n",num1);
    printf("%d\n",num2);
    return 0;
}
출력 결과:
10
10
```

int num1; 또는 char num2; => 자료형 변수명; 형식으로 해당 자료형을 선언할 수 있습니다. 위의 경우 선언을 함과 동시에 값을 둘 다 10으로 초기화 해주었습니다. 위와 같이 자료형을 이용하여 변수명을 자유롭게 설정하고 데이터 형식을 지정할 수 있습니다. 변수명을 자유롭게 설정할 수 있지만 아래의 규칙은 지켜야합니다.  

1. 영문 문자와 숫자 그리고 _(언더바)를 사용해야 합니다.
2. 대소문자를 구분합니다.
3. 문자나 _(언더바)부터 시작해야하며 숫자부터 시작하면 안됩니다.
4. C언어의 키워드(int, short, for, while 등 이미 기능이 약속된 단어들)는 사용할 수 없습니다.

위의 규칙을 지키고 적절한 자료형을 활용한다면 원하는 데이터를 담을 수 있는 변수를 선언할 수 있는 것입니다.  

### 정수 자료형의 종류와 표현하기
---
아래는 각 정수형 자료형이 차지하는 메모리 크기와 표현할 수 있는 숫자를 나타낸 것입니다.  

- char 1 Bytes => -128~127
- short (int) 2 Bytes => -32,768 ~ 32,767  
- int 4 Bytes => -2,147,483,648 ~ 2,147,438,647
- long (int) 4 Bytes => -2,147,483,648 ~ 2,147,483,647
- long long (int) 8 Bytes => -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
- unsigned char 1 Bytes => 0 ~ 255
- unsigned short (int) 2 Bytes => 0 ~ 65,535
- unsigned int 4 Bytes => 0 ~ 4,294,967,295
- unsigned long (int) 4 Bytes => 0 ~ 4,294,967,295
- unsigned long long (int) 8 Bytes => 0 ~ 18,446,744,073,709,551,615

서식문자는 char, short, int는 %d로 출력하고 long은 %ld, long long은 %lld로 출력합니다. 이걸 외우고다녀야 할까요? 다행히 자료형의 최대값과 최소값을 정의해주는 헤더 파일이 존재합니다.  

```
#include <stdio.h>
#include <limits.h>

int main() {
    char num1 = CHAR_MIN;
    short num2 = SHRT_MAX;
    int num3 = INT_MIN;
    long num4 = LONG_MAX;
    long long num5 = LONG_LONG_MIN;

    printf("char의 최소값 : %d\n", num1);
    printf("short의 최대값 : %d\n", num2);
    printf("int의 최소값 : %d\n", num3);
    printf("long의 최대값 : %ld\n", num4);
    printf("long long의 최소값 : %lld\n", num5);

    return 0;
}
출력 결과:
char의 최소값 : -128
short의 최대값 : 32767
int의 최소값 : -2147483648
long의 최대값 : 9223372036854775807
long long의 최소값 : -9223372036854775808
```

### 언더플로우와 오버플로우
---
위에서 정수 자료형들을 소개할 때에 각자 나타낼 수 있는 최소값과 최대값을 알려드렸습니다. 그렇다면 저 범위를 벗어나면 어떻게 될까요? 언더플로우 혹은 오버플로우가 발생하여 원하는 값이 아닌 다른 값이 나오게 됩니다.

![underflowoverflow](https://zerobugplz.github.io/images/studying/underflowoverflow.png)  
  
위의 사진은 char의 경우 입니다. char는 -128 ~ 127까지의 숫자를 표현할 수 있습니다. -129를 대입하면 어떤 값이 들어갈까요? 127이 나오며 이런 현상을 언더플로우라고 합니다. 그렇다면 128을 대입한다면 같은 원리로 -128이 나오게 되며 이런 현상을 오버플로우라고 합니다.

```
#include <stdio.h>

int main() {
    char num1 = -129;
    char num2 = 128;

    printf("%d\n",num1);
    printf("%d\n",num2);

    return 0;
}
출력 결과 :
127
-128
```

### 8진수와 16진수 사용하기
---
8진수는 숫자 앞에 0을 16진수는 숫자 앞에 0x을 붙이면 됩니다.  

```
#include <stdio.h>
int main()
{
    printf("%d\n",010);
    printf("%d\n",0x10);
    
    return 0;
}

출력 결과:
8
16
```

10을 출력하는데 앞에 0이 붙어서 8진수로 인식되어서 10진수로 8이 출력되고 앞에 0x가 붙으면 16진수로 인식되어 16이 출력됩니다. 8진수의 출력 서식문자는 %o 이고 16진수의 출력 서식문자는 %x입니다. 아래는 10진수 숫자 10이 8진수로 표현되면 12, 16진수로 표현되면 a임을 보여줍니다.  

```
#include <stdio.h>

int main()
{
    printf("%o\n",10);
    printf("%x\n",10);

    return 0;
}

출력 결과:
12
a
```

### 대입 연산시 자동적 형 변환
---
int i = 3.12211; 이면 i에는 무슨 값이 들어갈까요?  
**내림변환**이 이루어져서 i에는 3만 들어가게 됩니다. int가 정수 자료형이므로 소수점 이하자리를 버리게 되는 것이지요.  
double d = 3; 이면 d에는 무슨 값이 들어갈까요?  
**올림변환**이 이루어져서 d에는 3.0이 들어가게 됩니다. 이처럼 자료형에 따라 대입시 자동적으로 내림변환, 올림변환이 일어날 수 있습니다.

### 자료형의 크기 구하기와 정수 연산의 자동적 형 변환
---
해당 자료형의 크기를 구하는 연산자가 있으니 바로 sizeof 연산자 입니다. 다른 자료형에서도 동일한 방식으로 사용하니 이번에 설명하고 다음 자료형부터 따로 설명하지 않도록 하겠습니다.

```
#include <stdio.h>

int main() {
    short num = 1;
    int size;

    size = sizeof(num);

    printf("%d\n",size);

    return 0;
}
출력 결과 :
2
```

보시다시피 괄호 안의 자료형 크기를 리턴해줍니다. 그런데 코딩을 하다보면 아래와 같이 이상한 현상을 겪을 수 있습니다.

```
#include <stdio.h>

int main() {
    short num1 = 1;
    short num2 = 2;

    printf("%d\n",sizeof(num1+num2));

    return 0;
}
출력 결과 :
4
```

short 자료형과 short 자료형을 더해주면 short자료형이 다시 나와서 자료형의 크기가 2일 것 같지만 4가 출력됩니다. 컴파일러가 자동으로 연산을 하는 도중 int형으로 묵시적 변환을 해주기 때문입니다. 그 이유는 int형이 연산속도가 빠르기 때문에 CPU가 처리하기에 가장 적합한 int형으로 자동 변환하는 것입니다. 따라서 연산처리가 빈번한 경우 int형 변수를 선언하는 것이 좋습니다. 그럼 short형이나 char형은 불필요한 것일까요? 아닙니다. 데이터의 양이 많아서 연산속도보다 데이터의 크기를 줄이는 것이 더 중요한 데이터들이 있습니다. 예를들자면 MP3나 영상데이터 같은 경우입니다.

### 일반 연산에서 자동적 형변환과 명시적 형변환
---
서로 다른 자료형이 혼합하여 사용되는 경우, 더 큰 자료형으로 통일됩니다. 예를들어 int형 + double형 => double형 + double형으로 변환 => double 값이 되는 것입니다.

```
int i=1;
double d=3.14;

i + d => 1 + 3.14 => 1.0 + 3.14 => 4.14
```

사용자가 데이터 타입을 직접 변경할 수도 있으며 이것은 명시적 형변환이라고 합니다. 사용법은 사용자가 원하는 데이터 앞에 괄호를 열고 바꾸고 싶은 자료형을 써주면 됩니다. 아래는 int형 변수와 double 형 변수가 더해져서 double형 결과가 나올 것 같지만 사용자가 명시적으로 double형 변수 앞에 (int)라고 붙여주었기 때문에 int형 변수와 int형 변수가 더해진 결과와 같은 결과가 나오게 됩니다.  

```
#include <stdio.h>

int main()
{
    int i = 1;
    double d = 3.14;

    printf("%d",i+(int)d);

    return 0;
}
출력 결과:
4
```

### 크기가 표시된 정수 자료형 사용하기
---
int는 늘 크기가 4바이트 일까요? 아닙니다. CPU 아키텍쳐에 따라 그때 그때 다릅니다(물론 보통은 4바이트입니다). 프로그래밍을 하면서 이것은 큰 혼동을 안겨줄 수 있습니다. 어디서는 int가 2바이트이고 어디서는 4바이트이고 하면 유연한 프로그래밍을 하기가 어렵겠지요. C99 표준부터는 stdint.h 헤더파일이 이를 해결해주었습니다. 이제는 크기가 표시된 정수 자료형으로 변수를 선언할 수 있게 된 것입니다.

```
#include <stdio.h>
#include <stdint.h>

int main() {
    int8_t num1; // 8비트(1바이트) 크기의 부호있는 정수형 변수
    int16_t num2; // 16비트(2바이트) 크기의 부호있는 정수형 변수
    int32_t num3; // 32비트(4바이트) 크기의 부호있는 정수형 변수
    int64_t num4; // 64비트(8바이트) 크기의 부호있는 정수형 변수

    return 0;
}
```

### 컴퓨터가 정수를 표현하는 방법
---
컴퓨터는 대부분 정수를 표현할 때에 2의 보수라는 방식을 채택합니다. 2의 보수란 어떤 수를 커다란 2의 제곱수에서 빼서 얻은 이진수입니다. 2의 보수는 대부분의 산술연산에서 원래 숫자의 음수처럼 취급됩니다. 주어진 이진수보다 한 자리 높고 가장 높은 자리가 1이며 나머지가 0인 수에서 주어진 수를 빼서 얻은 수가 2의 보수입니다. 혹은 주어진 이진수의 모든 자리의 숫자를 반전(0을 1로, 1을 0으로)시킨 뒤 여기에 1을 더하면 2의 보수를 얻을 수 있습니다. char로 설명을 드려 보겠습니다.

```
char a = 1;
```

위의 상황에서 a변수에 저장된 값은 1바이트 자료형인 char로 선언 했으므로 8비트 00000001이 됩니다. 양수에서 char로 나타낼 수 있는 수가 127인 이유가 01111111(2진수)의 값이 127이기 때문입니다. 그렇다면 음수는 어떻게 나타낼까요?  
  
-1을 컴퓨터는 어떤 방식으로 저장하는지 알아보겠습니다.

1. 우선 양수로 표현하고 0을 1로, 1을 0으로 반전시킵니다. -1의 경우 00000001 => 11111110이 될 것입니다.
2. 1을 더해줍니다. 11111110 => 11111111이 될 것입니다.

이런 식으로 컴퓨터는 정수의 값을 양수에서 음수까지 0과 1만으로 저장하고 있다는 것을 알아두시면 좋습니다.